theory Samsung_SmartTag

begin

builtins: diffie-hellman

functions:

	//Constant
	zero_iv_const/0, gen/0, Mode_E2E/0, Mode_NoE2E/0,
	privacy_const/0, sign_const/0, update_const/0,
	
	/* Concatenation helper functions */
	first16bytes/1, last16bytes/1,
	
	/* ECDH key exchange */
	Secp256k1/2,
	
	/* ECIES: org.bouncycastle.jce.provider.BouncyCastleProvider */
	IES_enc/2, IES_dec/2 [destructor],
	AES_enc/3, AES_dec/3 [destructor],
	
	/* Hash function */
	HMAC_SHA256/2, SHA256/1,
	derive_key_from_pin/1,

	/* tracker */
	ah/2,
	kdf2/2,


	
equations:
	//Secp256k1(Secp256k1(gen, x), y) = Secp256k1(Secp256k1(gen, y), x),
	AES_dec(AES_enc(mes, k, v), k, v) = mes,
	IES_dec(IES_enc(m, dhkey_ab), dhkey_ab) = m

	
	
/* set input/output as precise as described */
export queries:
"
set preciseActions = true.
query x:bitstring; event(Secret(x)) && (attacker(x)).
"


/* set the public key */
let user0(~user_cloud_ch, ~user, ~encryption_key, ~seed, ~iv, ~pool, ~pin) = 
	
	let E2EMode = Mode_E2E in

	if (E2EMode = Mode_E2E) then 
	(
		/* set E2EMode is E2E, and store the password 6-digit PIN code */
		new ~d;
		let P = 'g' ^ ~d in
		new ~pin;

		/* Mitigation for V3 */
		new ~rt;

		let p_symkey = derive_key_from_pin(~pin) in
		new ~n;
		let enc_pri_o = AES_enc(d, p_symkey, ~n) in
		
		/*
			SmartTag: ~encryption_key, ~seed, ~iv, ~pool
			Key item: enc_pri_o, P, ~n, ~rt
		*/
		out(~user_cloud_ch, <~user, ~encryption_key, ~seed, ~iv, ~pool, enc_pri_o, P, ~n, ~rt>);

		
		event Step0oEnd();
		event Step0oE2EMode(~user, ~encryption_key, ~seed, ~iv, ~pool, enc_pri_o, P, ~n, ~rt)

	)
	// remove the NoE2E mode


let server0(~user_cloud_ch, ~database_pubkey) = 
	in(~user_cloud_ch, <~user, ~encryption_key, ~seed, ~iv, ~pool, enc_pri_o, P, ~n, ~rt>);
	/* 
		Mitigation:
			Calculate the current public key
	 */
	let Pi = P ^ rt in
	out(~database_pubkey, <~user, ~encryption_key, ~seed, ~iv, ~pool, enc_pri_o, Pi, ~n, ~rt>)


let tracker(~adv_ch, ~IRK, ~encryption_key, seed, iv, pool) =
	/* Bluetooth MAC address */
	new ~prand;
	let localHash = ah(~IRK, ~prand) in
	let ADV_addr = <~prand, localHash> in

	/* ID */
	let key1 = kdf2(~encryption_key, privacy_const) in
	new ~r2;
	let privID = AES_enc(<~r2, ~seed, ~r2> , key1, ~iv) in

	/* Signature */
	let sign_key = kdf2(~encryption_key, sign_const) in
	let signature = AES_enc(<~privID, Mode_E2E>, sign_key, ~iv) in

	/* BLE advertisement broadcast */
	out(~adv_ch, <ADV_addr, privID, Mode_E2E, signature, "BLE adv">)


// Send location report to server1
let participant(~adv_ch, ~finder_cloud_ch) = 
	in(~adv_ch, <ADV_addr, privID, E2EMode, signature, "BLE adv">)
	new ~location;

	new ~exp_f;
  let pri_f = ~exp_f in

  if E2EMode = Mode_E2E then (
    out(~finder_cloud_ch, <privID, 'f_s'>);
    in(~finder_cloud_ch, <pub_o, 'f_s'>);
    let pub_f = gen ^ pri_f in
    let dhkey_of = pub_o ^ pri_f in
    let sealedbox_loc = IES_enc(~location, dhkey_of) in
    
    out(~finder_cloud_ch, <privID, E2EMode, signature, <pub_f, sealedbox_loc>, 'f_s'>);
    
    event Step1fEnd();
    event Step1fE2EMode(privID, E2EMode, signature, pri_f, pub_f, sealedbox_loc, ~location)
  )
  // remove the NoE2E mode


// Receive and store location reports
let server1(~database_pubkey, ~finder_cloud_ch, ~database_report) = 
	/* Fetch the database_pubkey */
	in(~database_pubkey, <user, encryption_key, seed, iv, pool, enc_pri_o, Pi, n, rt>);
	in(~finder_cloud_ch, <privID, 'f_s'>);

	// Actually, it is more possible that Samsung 
	let key1 = kdf2(encryption_key, privacy_const) in
	let <r2, seed_report, r2> = AES_enc(privID , key1, iv) in
	if (seed_report = seed) then (
		out(~finder_cloud_ch, <Pi, 'f_s'>);
		in(~finder_cloud_ch, <privID, E2EMode, signature, <pub_f, sealedbox_loc>, 'f_s'>);
		let sign_key = kdf2(encryption_key, sign_const) in
		if (signature = AES_enc(<privID, E2EMode>, sign_key, iv) ) then (
			// if not work, send it twice or more
			!out(~database_report, <user, pub_f, sealedbox_loc, enc_pri_o, Pi, n, rt>)
		)
	)



/* Fetch location report */
let user1(~user_cloud_ch, ~user, ~pin) = 
	out(~user_cloud_ch, <~user, 'o_s'>);
	in(~user_cloud_ch, <~user1, pub_f, sealedbox_loc, enc_pri_o, Pi, n, rt>);

	let p_symkey = derive_key_from_pin(~pin) in
	let d = AES_dec(enc_pri_o, p_symkey, n) in
	let di = d * rt in

	/* Decrypt location report */
	let dhkey_fo = pub_f ^ di in
	let loc = IES_dec(sealedbox_loc, dhkey_fo) in


let server2(~database_report, ~user_cloud_ch) = 
	/* Fetch the database_report */
	in(~database_report, <user, pub_f, sealedbox_loc, enc_pri_o, Pi, n, rt>);
	in(~user_cloud_ch, <~user1, 'o_s'>);
	if (user = user1) then (
		out(~user_cloud_ch, <~user1, pub_f, sealedbox_loc, enc_pri_o, Pi, n, rt>)
	)



process:

	// Public Channel 
	new ~cloud_ch: channel;
	out(~cloud_ch);
	
	new ~adv_ch: channel;
	out(~adv_ch);

	new ~attacker_ch: channel;
	out(~attacker_ch);
	
	// Private Channel
	new ~user_cloud_ch: channel;
	new ~finder_cloud_ch: channel;
	new ~database_pubkey: channel;
	new ~database_report: channel;

	// Account
	new ~owner;
	new ~attacker;
	
	/* sensitive data, length < 16 bytes */
	new ~location;
	event Secret(~location);

	/* The result of the initialization phase for owner */
	new ~encryption_key, ~seed, ~iv, ~pool, ~IRK;
	new ~pin;

	/* For attacker */
	//here

	(
		(user0(~user_cloud_ch, ~owner, ~encryption_key, ~seed, ~iv, ~pool, ~pin)) | 
		(server0(~user_cloud_ch, ~database_pubkey)) |

		(tracker(~adv_ch, ~IRK, ~encryption_key, seed, iv, pool)) | 
		(participant(~adv_ch, ~finder_cloud_ch)) |
		(server1(~database_pubkey, ~finder_cloud_ch, ~database_report)) |
		(user1(~user_cloud_ch, ~owner, ~pin)) |
		(server2(~database_report, ~user_cloud_ch)) |

		(user1(~attacker_ch, ~attacker, ~pin)) |
		(server2(~database_report, ~attacker_ch))
	)


lemma confidentiality [ output=[spthy] ]:
"
	( 
		All x #i. (Secret(x) @ i ==> not (Ex #k. KU(x) @ k))
	)
"

end
