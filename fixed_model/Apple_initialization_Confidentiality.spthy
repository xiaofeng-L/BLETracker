theory Apple_AirTag

begin

builtins: diffie-hellman

functions:
	sigtrue/0,
	/* private value */
	/* Apple cloud public-private key: Qe-Qd  */
	qe/0 [private],
	qa/0 [private],
	
	sv/0 [private], 
	
	UUID_paired/0 [private],

	/* constant value */
	ServerSharedSecret_const/0,
	PairingSession_const/0,
	SerialNumberProtection_const/0,
	bound_const/0,
	unbound_const/0,
	zero_const/0, btlk/0, SALT/0, brle/0,
	addr_A/0, addr_B/0,
	iocap_A/0, iocap_B/0,

	yes_confirm_const/0,
	no_confirm_const/0,

	addrA_const/0,
	addrB_const/0,

	len_q/0,
	first_nbits/2,

	/* ECDH key exchange 
	gen/0,
	*/
	pk/1,
	sign/2,
	verify/3,

	add/2,

	SHA256/1,
	HMAC_SHA256/2,
	AES_CMAC/2,
	kdf/2,
	AES_GCM_enc/3, AES_GCM_dec/3 [destructor],

	/* hash table */
	derive_hashed_sn/1,
	hash_table/1 [destructor],

	/* Calculate all id */
	get_id/2

  
equations:
	AES_GCM_dec(AES_GCM_enc(mes, k, v), k, v) = mes,
	hash_table(derive_hashed_sn(x)) = x,
	verify(sign(m,sk), m, pk(sk)) = sigtrue
  


export queries:
"
set preciseActions = true.
query attacker(sv).
"

options: enableStateOpt, compress-events,
translation-allow-pattern-lookups

/*
  Mitigation:
	  Change 1: 
	  	C1 = SHA256(s||R), C2 = {S', R'}, C3 = {s, R}
	  	{SKN, SKS} = KDF(x(P), x(r \cdot R')) = KDF(x(P), x(r' \cdot R)) 
			unchanged: P = S'+ s \cdot G
		Change 2:
			unchanged: H1=SHA256(C2)
			S2=ECDSA(UUID, sessionNonce, SeedS, H1, E1, E3, "C1")
			E2=ECIES(<SessionNonce, token, UUID, SN, data, Version, H1, SeedK1, "C1">, Q_E)
*/


let server(~sec_ch, ~UUID, ~token, ~UUID_paired) = 
	/* initial setting */
	/* Receive: E2 */
	/* Send: iCloudldentifier, SeedS, S2, E3(Encrypted software token) */
	new ~iCloudldentifier;

	in(~sec_ch, <H1, E2, 's_c'>);
	let <pub_2, E2_data_e> = E2 in
	let dhkey_2 = pub_2 ^ qe in
	
	let key_2 = kdf(dhkey_2, pub_2) in
	let iv_2 = kdf(dhkey_2, pub_2) in

	// change2: E2
	let <SessionNonce, token, UUID, SN, data, Version, E1, SeedK1, C1> = AES_GCM_dec(E2_data_e, key_2, iv_2) in

	if (UUID = UUID_paired) then (
		0 
	)
	else(
		new ~token_new;
		event TokenNewSource(~token_new);
		new ~SeedS;

		let ServerSharedSecret = kdf(<~SeedS, ~SeedK1>, ServerSharedSecret_const) in
		
		let K1 = kdf(ServerSharedSecret, PairingSession_const) in
		let IV1 = kdf(ServerSharedSecret, PairingSession_const) in
		
		let KSN = kdf(ServerSharedSecret, SerialNumberProtection_const) in
		let E3 = AES_GCM_enc(~token_new, K1, IV1) in
		
		event E3Source(E3);
		
		/* ECDSA Sign */
		// change2
		let S2_data = <UUID, SessionNonce, ~SeedS, H1, E1, E3, C1> in

		let S2 = sign(S2_data, qa) in
		event C2ParamSource(E3, ~SeedS, S2, ~iCloudldentifier);
		out(~sec_ch, <~iCloudldentifier, ~SeedS, S2, E3, 's_c'>)
		
	)

	  


let stepc(~s, ~sec_ch : channel) = 

	/* BLE. PK exchange */
	new ~pri_a;
	let pk_A = 'g' ^ ~pri_a in
	out(<pk_A, 'c_p'>);
	in(<pk_B, 'c_p'>);
	let dhkey_AB = pk_B ^ ~pri_a in

	/* BLE. JW auth 1 */
	new ~na;
	let ra = zero_const in
	let rb = zero_const in
	in(<cb, 'c_p'>);
	out(<~na, 'c_p'>);
	in(<nb, 'c_p'>);

	/* BLE. JW auth 2 */
	if cb = HMAC_SHA256(nb, <pk_B, pk_A, zero_const>) then (
			
		event Stepc0();
		
		let ea = HMAC_SHA256(dhkey_AB, <~na, nb, rb, iocap_A, addr_A, addr_B>) in
		out(<ea, 'c_p'>);
		in(<eb, 'c_p'>);

		/* BLE. LK and LTK generation */
		if eb = HMAC_SHA256(dhkey_AB, <nb, ~na, ra, iocap_B, addr_B, addr_A>) then (
		
		event Stepc1();
		
		let lk_key = HMAC_SHA256(dhkey_AB, <~na, nb, btlk, addr_A, addr_B>) in
		let le_key = AES_CMAC(AES_CMAC(SALT, lk_key), brle) in

		/* Data tran: seesion key generation */
		new ~skdm;
		new ~ivm;
		out(<~skdm, ~ivm, 'c_p'>);
		in(<skds, ivs,  'c_p'>);
		let session_k = AES_CMAC(le_key, <skds, ~skdm>) in
		let session_n = <ivs, ~ivm> in

		/* Data tran: id sharing */
		/* Send to AirTag: SessionNonce, E1 */
		new ~SessionNonce;
		event SessionNonceSource(~SessionNonce);
		new ~E1;
		event E1Source(~E1);
		out(<AES_GCM_enc(<~SessionNonce, 'SessionNonce'>, session_k, session_n), AES_GCM_enc(<~E1, 'E1'>, session_k, session_n), 'c_p'>);

		/* Receive from AirTag: C1, E2 */
		in(<C1e, E2_e, 'c_p'>);
		let <C1, 'C1'> = AES_GCM_dec(C1e, session_k, session_n) in
		let <E2, 'E2'> = AES_GCM_dec(E2_e, session_k, session_n) in

		new ~s_;
		new ~r_;
		// change1
		let R_ = 'g' ^ ~r_ in
		let pkS = 'g' ^ ~s_ in
		
		/* Send to Server: E2 */
		/* Receive from Server: iCloudldentifier, SeedS, S2, E3(Encrypted software token) */
		// change1
		let H1 = SHA256(<pkS, R_>) in
		out(~sec_ch, <H1, E2, 's_c'>);
		
		in(~sec_ch, <iCloudldentifier, SeedS, S2, E3, 's_c'>);
		event RecvE3(E3);

		/* Send to AirTag: C2(S', r'), E3, SeedS, S2, iCloudldentifier */
		
		let c2_encrypted_param = AES_GCM_enc(<pkS, R_, E3, SeedS, S2, iCloudldentifier>, session_k, session_n) in
		event SendC2Param(E3, SeedS, S2, iCloudldentifier);
		out(<c2_encrypted_param, 'c_p'>);

		/*
			out(<AES_GCM_enc(pkS, session_k, session_n), AES_GCM_enc(~r_, session_k, session_n), 
			AES_GCM_enc(E3, session_k, session_n), AES_GCM_enc(SeedS, session_k, session_n),
			AES_GCM_enc(S2, session_k, session_n), AES_GCM_enc(iCloudldentifier, session_k, session_n), 'c_p'>);
		*/
		/* Receive from AirTag: C3, Status, E4 */
		/*
			in(<s_e, r_e, Status_e, E4_e, 'c_p'>);
			let s = AES_GCM_dec(s_e, session_k, session_n) in
			let r = AES_GCM_dec(r_e, session_k, session_n) in
			let Status = AES_GCM_dec(Status_e, session_k, session_n) in
			let E4 = AES_GCM_dec(E4_e, session_k, session_n) in
		*/
		in(<c3_encrypted_param, 'c_p'>);
		// change1
		let <s, R, other_param> = AES_GCM_dec(c3_encrypted_param, session_k, session_n) in
		
		
		/* Verify C1 */
		// change1
		if C1 = SHA256(<s, R>) then (
			let S = 'g' ^ s in
			let P = add(S, pkS) in
			let d = add(s, ~s_) in
			// let rotation = <r, ~r_> in
			let rotation = R ^ ~r_ in
			let id = get_id(P, rotation) in
			event Stepc2();
			out(~sec_ch, <id, 'id_c'>)
			
	) 
	))



let stepp(~s, ~sec_ch, ~UUID, ~token) = 
	let Qe = 'g' ^ qe in
	let Qa = pk(qa) in


	/* BLE. PK exchange */
	new ~pri_b;
	let pk_B = 'g' ^ ~pri_b in
	in(<pk_A, 'c_p'>);
	out(<pk_B, 'c_p'>);
	let dhkey_BA = pk_A ^ ~pri_b in

	/* BLE. JW auth 1 */
	new ~nb;
	let ra = zero_const in
	let rb = zero_const in
	let cb = HMAC_SHA256(~nb, <pk_B, pk_A, zero_const>) in
	out(<cb, 'c_p'>);
	in(<na, 'c_p'>);
	out(<~nb, 'c_p'>);

	/* BLE. JW auth 2 */
	let eb = HMAC_SHA256(dhkey_BA, <~nb, na, ra, iocap_B, addr_B, addr_A>) in
	in(<ea, 'c_p'>);
	out(<eb, 'c_p'>);

	/* BLE. LK and LTK generation */
	if ea = HMAC_SHA256(dhkey_BA, <na, ~nb, rb, iocap_A, addr_A, addr_B>) then (
		
		let lk_key = HMAC_SHA256(dhkey_BA, <na, ~nb, btlk, addr_A, addr_B>) in
		let le_key = AES_CMAC(AES_CMAC(SALT, lk_key), brle) in

		/* Data tran: seesion key generation */
		new ~skds;
		new ~ivs;    
		in(<skdm, ivm, 'c_p'>);
		out(<~skds, ~ivs, 'c_p'>);
		let session_k = AES_CMAC(le_key, <~skds, skdm>) in
		let session_n = <~ivs, ivm> in

		/* Data tran: id sharing */

		in(<SessionNonce_e, E1_e, 'c_p'>);
		let <SessionNonce, 'SessionNonce'> = AES_GCM_dec(SessionNonce_e, session_k, session_n) in
		let <E1, 'E1'> = AES_GCM_dec(E1_e, session_k, session_n) in
		event Stepp1();
		/* Send: C1, E2(SessionNonce, token, UUID, SN, data, Version, E1, SeedK1) */
		new ~s;
		new ~r;
		// change1
		let R = 'g' ^ ~r in
		let S = 'g' ^ ~s in
		// change1
		let C1 = SHA256(<~s, ~R>) in

		new ~SeedK1;
		new ~exp_2;
		new ~token;
		new ~SN;
		new ~data;
		new ~Version;

		let pub_2 = 'g' ^ ~exp_2 in
		let dhkey_2 = Qe ^ ~exp_2 in
		
		let key_2 = kdf(dhkey_2, pub_2) in
		let iv_2 = kdf(dhkey_2, pub_2) in
		
		// change2
		let E2_data = <SessionNonce, ~token, ~UUID, ~SN, ~data, ~Version, E1, ~SeedK1, C1> in
		event SendSessionNonce(SessionNonce);
		event SendE1(E1);
		let E2 = <pub_2, AES_GCM_enc(E2_data, key_2, iv_2)> in
		out(<AES_GCM_enc(<C1, 'C1'>, session_k, session_n), AES_GCM_enc(<E2, 'E2'>, session_k, session_n), 'c_p'>);


		/* Receive: C2(S', r'), E3, SeedS, S2(x,y), iCloudldentifier */
		/*
		in(<se, re, E3_e, SeedS_e, S2_e, iCe, 'c_p'>);
		let pkS = AES_GCM_dec(se, session_k, session_n) in
		let r_ = AES_GCM_dec(re, session_k, session_n) in
		let E3 = AES_GCM_dec(E3_e, session_k, session_n) in
		let SeedS = AES_GCM_dec(SeedS_e, session_k, session_n) in
		let S2 = AES_GCM_dec(S2_e, session_k, session_n) in
		let iCloudldentifier = AES_GCM_dec(iCe, session_k, session_n) in
		*/

		
		in(<c2_encrypted_param, 'c_p'>);
		// change1
		let <pkS, R_, E3, SeedS, S2, iCloudldentifier> = AES_GCM_dec(c2_encrypted_param, session_k, session_n) in
		
		let P = add(S, pkS) in

		let ServerSharedSecret = kdf(<SeedS, ~SeedK1>, ServerSharedSecret_const) in
		let K1 = kdf(ServerSharedSecret, PairingSession_const) in
		let IV1 = kdf(ServerSharedSecret, PairingSession_const) in
		let KSN = kdf(ServerSharedSecret, SerialNumberProtection_const) in

		/* Check signature: S2(UUID, SessionNonce, SeedS, SHA-256(C2), E1, E3)*/
		// change1
		let H1 = SHA256(<pkS, R_>) in
		// change2
		let S2_data = <~UUID, SessionNonce, SeedS, H1, E1, E3, C1> in


		if (verify(S2, S2_data, Qa) = sigtrue) then (
			event Stepp2();
			/* Decrypt E3 */
			let tk_new = AES_GCM_dec(E3, K1, IV1) in

			/* Send: C3, Status, E4(UUID,SN,SessionNonce,E1,token_new, Status) */
			new ~Status;
			/*
			out(<AES_GCM_enc(~s, session_k, session_n), 
			AES_GCM_enc(~r, session_k, session_n), 
			AES_GCM_enc(<~UUID, ~SN, SessionNonce, E1, tk_new, ~Status>, session_k, session_n), 'c_p'>);
			*/
			// change1
			let c3_encrypted_param = AES_GCM_enc(<~s, ~R, <~UUID, ~SN, SessionNonce, E1, tk_new, ~Status>>,  session_k, session_n) in
			event SendSessionNonce(SessionNonce);
			event SendE1(E1);
			event SendTokenNew(tk_new);
			out(<c3_encrypted_param, 'c_p'>);
			
			// change1
			let rotation = R_ ^ ~r in

			let id = get_id(P, rotation) in
			out(~sec_ch, <id, 'id_p'>);
			in(~sec_ch, <confirm, 'user_ui'>);
			if (confirm = yes_confirm_const) then (
			  new ~tmp;
			  out(<~tmp, AES_GCM_enc(sv, id, ~tmp), 'open_ch'>);
			  event Secret(sv)

	)
	))



let god(~sec_ch : channel) = 
	in(~sec_ch, <id_c, 'id_c'>);
	in(~sec_ch, <id_p, 'id_p'>);
	if id_c = id_p then (
		out(~sec_ch, <yes_confirm_const, 'user_ui'>);
		event PairSuccess(id_c, id_p)
	)


process:
	new ~s;
	new ~sec_ch : channel;
	(
	( steps(~sec_ch) ) | ( stepp(~s, ~sec_ch) ) | ( stepc(~s, ~sec_ch) ) | ( god(~sec_ch) )
	)



lemma e1_source[sources, output=[spthy]]:
"
	( All e #i. SendE1(e) @ i ==> 
		(Ex #t. E1Source(e) @ t & t < i) 
	)
"

lemma sn_source[sources, output=[spthy]]:
"
	( All e #i. SendSessionNonce(e) @ i ==> 
		(Ex #t. SessionNonceSource(e) @ t & t < i) 
	)
"

lemma tk_new_source[sources, output=[spthy]]:
"
	( All e #i. SendTokenNew(e) @ i ==> 
		(Ex #t. TokenNewSource(e) @ t & t < i) 
	)
"

lemma c2_param_source[sources, output=[spthy]]:
"
	( All a b c d #i. SendC2Param(a, b, c, d) @ i ==> 
		(Ex #t. C2ParamSource(a, b, c, d) @ t & t < i) 
	)
"


lemma confidentiality [ output=[spthy] ]:
"
	( 
		All x #i. (Secret(x) @ i ==> not (Ex #k. KU(x) @ k))
	)
"
/*
lemma sanity_check1[output=[proverif]]: exists-trace
"
	(Ex x #i. Secret(x) @ i )
"

lemma sanity_check2[output=[proverif]]: exists-trace
"
	(Ex #i. Stepp1() @ i )
"

lemma sanity_check3[output=[proverif]]: exists-trace
"
	(Ex #i. Stepc0() @ i )
"

lemma sanity_check4[output=[proverif]]: exists-trace
"
	(Ex #i. Stepc1() @ i )
"

lemma sanity_check5[output=[proverif]]: exists-trace
"
	(Ex #i. Stepc2() @ i )
"

lemma sanity_check6[output=[proverif]]: exists-trace
"
	(Ex #i. Stepp2() @ i )
"
*/

/*
lemma pair_consistency:
"
	( 
		All id1 id2 #i #j .
			( PairSuccess(id1, id2) @ i ) & (Paired() @ j) 
				==> F
	)
"
*/
end
