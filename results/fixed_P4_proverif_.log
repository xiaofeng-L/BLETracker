/tmp/tmp.BL0vL3OUuQ/P4_fixed_V4_Samsung_initialization_confidentiality.spthy.gs
Starting the transformation...
Parsing the file...
Writing in the output file...
Translation complete !
Linear part:
exp(exp(g,a),b) = exp(exp(g,b),a)
Completing equations...
Completed equations:
exp(exp(g,a),b) = exp(exp(g,b),a)
Convergent part: No equation.
Process 0 (that is, the initial process):
{1}new sec_ch_1: channel;
{2}new pri_p_1: bitstring;
{3}let pub_p_1: bitstring = exp(g,pri_p_1) in
{4}new sn_1: bitstring;
{5}!
(
    {6}event Bounded(sn_1);
    {7}in(sec_ch_1, (hashed_sn_p_1: bitstring,(rand_1: bitstring,=pre_app1)));
    {8}let sn_11: bitstring = hash_table(hashed_sn_p_1) in
    {9}if (sn_11 = sn_1) then
    {10}new pri_c_1: bitstring;
    {11}let pub_c_1: bitstring = exp(g,pri_c_1) in
    {12}let dhkey_PC_1: bitstring = exp(pub_p_1,pri_c_1) in
    {13}let encryption_key_1: bitstring = derive_encryption_key(dhkey_PC_1,rand_1) in
    {14}event SendPubkey(sec_ch_1,pri_c_1,pub_c_1);
    {15}out(sec_ch_1, (encryption_key_1,(pub_c_1,pre_app1)));
    {16}in(sec_ch_1, (sn_p1_1: bitstring,=pre_app1));
    {17}event StepsEnd1;
    {18}if (sn_p1_1 = sn_1) then
        {19}out(sec_ch_1, (bound_const,pre_app1))
    else
        {20}out(sec_ch_1, (unbound_const,pre_app1));
        {21}in(sec_ch_1, (sn_p_1: bitstring,(encryption_key_c_1: bitstring,=pre_app1)));
        {22}if (sn_p_1 = sn_1) then
            {23}out(sec_ch_1, (bound_const,pre_app1))
        else
            {24}if ((sn_11 = sn_p_1) && (encryption_key_1 = encryption_key_c_1)) then
            {25}event StepsEnd2;
            {26}new secure_param_1: bitstring;
            {27}event SendSecureParam(secure_param_1);
            {28}out(sec_ch_1, (secure_param_1,pre_app1));
            {29}let privacy_key_1: bitstring = kdf2(encryption_key_1,privacy_const) in
            {30}let id_1: bitstring = get_id(privacy_key_1,secure_param_1,secure_param_1,secure_param_1) in
            {31}out(sec_ch_1, (id_1,id_s))
) | (
    {32}in(att, (hashed_sn_p: bitstring,=open_ch));
    {33}new rand: bitstring;
    {34}out(sec_ch_1, (hashed_sn_p,(rand,pre_app1)));
    {35}in(sec_ch_1, (encryption_key: bitstring,(pub_c: bitstring,=pre_app1)));
    {36}event ReceivePubKey(sec_ch_1,pub_c);
    {37}out(att, (rand,(pub_c,open_ch)));
    {38}let auth_key_1: bitstring = kdf2(encryption_key,bleAuthentication_const) in
    {39}new n1_1: bitstring;
    {40}out(att, (n1_1,open_ch));
    {41}in(att, (n2_1: bitstring,=open_ch));
    {42}let encrypted_nonce1_1: bitstring = AES_enc(smartthings_const,auth_key_1,n2_1) in
    {43}out(att, (encrypted_nonce1_1,open_ch));
    {44}in(att, (encrypted_nonce2_1: bitstring,=open_ch));
    {45}let dec_mes_2_1: bitstring = AES_dec(encrypted_nonce2_1,auth_key_1,n1_1) in
    {46}event StepcEnd1;
    {47}let =smartthings_const = dec_mes_2_1 in
    {48}let link_key_1: bitstring = kdf2(encryption_key,n2_1) in
    {49}in(att, (encrypted_sn_p1_1: bitstring,=open_ch));
    {50}let sn_p1: bitstring = AES_dec(encrypted_sn_p1_1,link_key_1,n2_1) in
    {51}event ReceiveSn(sn_p1);
    {52}out(sec_ch_1, (sn_p1,pre_app1));
    {53}in(att, (encrypted_sn_p_1: bitstring,=open_ch));
    {54}let sn_p: bitstring = AES_dec(encrypted_sn_p_1,link_key_1,n2_1) in
    {55}event ReceiveSn(sn_p);
    {56}out(sec_ch_1, (sn_p,(encryption_key,pre_app1)));
    {57}in(sec_ch_1, (isbound_1: bitstring,=pre_app1));
    {58}if (isbound_1 = unbound_const) then
    {59}in(sec_ch_1, (secure_param: bitstring,=pre_app1));
    {60}event ReceiveSecureParam(secure_param);
    {61}let encrypted_param_1: bitstring = AES_enc(secure_param,link_key_1,n2_1) in
    {62}out(att, (encrypted_param_1,open_ch));
    {63}let privacy_key: bitstring = kdf2(encryption_key,privacy_const) in
    {64}let id: bitstring = get_id(privacy_key,secure_param,secure_param,secure_param) in
    {65}event StepcEnd2
) | (
    {66}let pub_p_11: bitstring = exp(g,pri_p_1) in
    {67}let hashed_sn_1: bitstring = derive_hashed_sn(sn_1) in
    {68}out(att, (hashed_sn_1,open_ch));
    {69}in(att, (rand_2: bitstring,(pub_c_2: bitstring,=open_ch)));
    {70}let dhkey_CP_1: bitstring = exp(pub_c_2,pri_p_1) in
    {71}let encryption_key_2: bitstring = derive_encryption_key(dhkey_CP_1,rand_2) in
    {72}let auth_key: bitstring = kdf2(encryption_key_2,bleAuthentication_const) in
    {73}new n2: bitstring;
    {74}out(att, (n2,open_ch));
    {75}in(att, (n1: bitstring,=open_ch));
    {76}let encrypted_nonce2: bitstring = AES_enc(smartthings_const,auth_key,n1) in
    {77}out(att, (encrypted_nonce2,open_ch));
    {78}in(att, (encrypted_nonce1: bitstring,=open_ch));
    {79}let dec_mes_1_1: bitstring = AES_dec(encrypted_nonce1,auth_key,n2) in
    {80}event SteppEnd1;
    {81}let =smartthings_const = dec_mes_1_1 in
    {82}let link_key: bitstring = kdf2(encryption_key_2,n2) in
    {83}let encrypted_sn_p: bitstring = AES_enc(sn_1,link_key,n2) in
    {84}event SendSn(sn_1,encrypted_sn_p);
    {85}out(att, (encrypted_sn_p,open_ch));
    {86}out(att, (encrypted_sn_p,open_ch));
    {87}in(att, (encrypted_param: bitstring,=open_ch));
    {88}let secure_param_2: bitstring = AES_dec(encrypted_param,link_key,n2) in
    {89}let privacy_key_2: bitstring = kdf2(encryption_key_2,privacy_const) in
    {90}let id_2: bitstring = get_id(privacy_key_2,secure_param_2,secure_param_2,secure_param_2) in
    {91}out(sec_ch_1, (id_2,(sn_1,id_p)));
    {92}event SteppEnd2
) | (
    {93}in(sec_ch_1, (id_s_1: bitstring,=id_s));
    {94}in(sec_ch_1, (id_p_1: bitstring,(sn: bitstring,=id_p)));
    {95}let =id_s_1 = id_p_1 in
    {96}event Secret_ID(id_s_1)
)


--------------------------------------------------------------
Verification summary:

No query in the input file.
--------------------------------------------------------------

