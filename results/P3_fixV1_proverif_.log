/tmp/tmp.YRXBrFSsWP/Samsung_initialization_Authentication_fixed_V1_foundV4.spthy.gs
Starting the transformation...
Parsing the file...
Writing in the output file...
Translation complete !
Linear part:
exp(exp(g,a),b) = exp(exp(g,b),a)
Completing equations...
Completed equations:
exp(exp(g,a),b) = exp(exp(g,b),a)
Convergent part: No equation.
Process 0 (that is, the initial process):
{1}new sec_ch_1: channel;
{2}event SecureChannel(sec_ch_1);
{3}!
(
    {4}in(sec_ch_1, (sn_owner_1: bitstring,=sn_owner));
    {5}event Bounded(sn_owner_1);
    {6}let sn1_1: bitstring = serial_number_const in
    {7}in(att, (hashed_sn_p_1: bitstring,(rand_1: bitstring,=pre_app1)));
    {8}let sn_1: bitstring = hash_table(hashed_sn_p_1) in
    {9}let pri_p_1: bitstring = kdf1(sn_1) in
    {10}let pub_p_1: bitstring = exp(g,pri_p_1) in
    {11}new pri_c_1: bitstring;
    {12}let pub_c_1: bitstring = exp(g,pri_c_1) in
    {13}let dhkey_PC_1: bitstring = exp(pub_p_1,pri_c_1) in
    {14}let encryption_key_1: bitstring = derive_encryption_key(dhkey_PC_1,rand_1) in
    {15}event SendPubkey(sec_ch_1,pri_c_1,pub_c_1);
    {16}out(att, (encryption_key_1,(pub_c_1,pre_app1)));
    {17}in(att, (sn_p1_1: bitstring,=pre_app1));
    {18}event StepsEnd1;
    {19}if (sn_p1_1 = sn_owner_1) then
        {20}out(att, (bound_const,pre_app1))
    else
        {21}out(att, (unbound_const,pre_app1));
        {22}in(att, (sn_p_1: bitstring,(encryption_key_c_1: bitstring,=pre_app1)));
        {23}if (sn_p_1 = sn_owner_1) then
            {24}out(att, (bound_const,pre_app1))
        else
            {25}if ((sn_1 = sn_p_1) && (encryption_key_1 = encryption_key_c_1)) then
            {26}event StepsEnd2;
            {27}new secure_param_1: bitstring;
            {28}event SendSecureParam(secure_param_1);
            {29}out(att, (secure_param_1,pre_app1));
            {30}let privacy_key_1: bitstring = kdf2(encryption_key_1,privacy_const) in
            {31}let id_1: bitstring = get_id(privacy_key_1,secure_param_1,secure_param_1,secure_param_1) in
            {32}out(sec_ch_1, (id_1,id_s))
) | (
    {33}in(att, (hashed_sn_p: bitstring,=open_ch));
    {34}new rand: bitstring;
    {35}out(att, (hashed_sn_p,(rand,pre_app1)));
    {36}in(att, (encryption_key: bitstring,(pub_c: bitstring,=pre_app1)));
    {37}event ReceivePubKey(sec_ch_1,pub_c);
    {38}out(att, (rand,(pub_c,open_ch)));
    {39}let auth_key_1: bitstring = kdf2(encryption_key,bleAuthentication_const) in
    {40}new n1_1: bitstring;
    {41}out(att, (n1_1,open_ch));
    {42}in(att, (n2_1: bitstring,=open_ch));
    {43}let encrypted_nonce1_1: bitstring = AES_enc(smartthings_const,auth_key_1,n2_1) in
    {44}out(att, (encrypted_nonce1_1,open_ch));
    {45}in(att, (encrypted_nonce2_1: bitstring,=open_ch));
    {46}let dec_mes_2_1: bitstring = AES_dec(encrypted_nonce2_1,auth_key_1,n1_1) in
    {47}event StepcEnd1;
    {48}let =smartthings_const = dec_mes_2_1 in
    {49}let link_key_1: bitstring = kdf2(encryption_key,n2_1) in
    {50}in(att, (encrypted_sn_p1_1: bitstring,=open_ch));
    {51}let sn_p1: bitstring = AES_dec(encrypted_sn_p1_1,link_key_1,n2_1) in
    {52}event ReceiveSn(sn_p1);
    {53}out(att, (sn_p1,pre_app1));
    {54}in(att, (encrypted_sn_p_1: bitstring,=open_ch));
    {55}let sn_p: bitstring = AES_dec(encrypted_sn_p_1,link_key_1,n2_1) in
    {56}event ReceiveSn(sn_p);
    {57}out(att, (sn_p,(encryption_key,pre_app1)));
    {58}in(att, (isbound_1: bitstring,=pre_app1));
    {59}if (isbound_1 = unbound_const) then
    {60}in(att, (secure_param: bitstring,=pre_app1));
    {61}event ReceiveSecureParam(secure_param);
    {62}let encrypted_param_1: bitstring = AES_enc(secure_param,link_key_1,n2_1) in
    {63}out(att, (encrypted_param_1,open_ch));
    {64}let privacy_key: bitstring = kdf2(encryption_key,privacy_const) in
    {65}let id: bitstring = get_id(privacy_key,secure_param,secure_param,secure_param) in
    {66}event StepcEnd2
) | (
    {67}let sn: bitstring = serial_number_const in
    {68}out(sec_ch_1, (sn,sn_owner));
    {69}let hashed_sn_1: bitstring = derive_hashed_sn(sn) in
    {70}let pri_p: bitstring = kdf1(sn) in
    {71}let pub_p: bitstring = exp(g,pri_p) in
    {72}out(att, (hashed_sn_1,open_ch));
    {73}in(att, (rand_2: bitstring,(pub_c_2: bitstring,=open_ch)));
    {74}let dhkey_CP_1: bitstring = exp(pub_c_2,pri_p) in
    {75}let encryption_key_2: bitstring = derive_encryption_key(dhkey_CP_1,rand_2) in
    {76}let auth_key: bitstring = kdf2(encryption_key_2,bleAuthentication_const) in
    {77}new n2: bitstring;
    {78}out(att, (n2,open_ch));
    {79}in(att, (n1: bitstring,=open_ch));
    {80}let encrypted_nonce2: bitstring = AES_enc(smartthings_const,auth_key,n1) in
    {81}out(att, (encrypted_nonce2,open_ch));
    {82}in(att, (encrypted_nonce1: bitstring,=open_ch));
    {83}let dec_mes_1_1: bitstring = AES_dec(encrypted_nonce1,auth_key,n2) in
    {84}event SteppEnd1;
    {85}let =smartthings_const = dec_mes_1_1 in
    {86}let link_key: bitstring = kdf2(encryption_key_2,n2) in
    {87}let encrypted_sn_p: bitstring = AES_enc(sn,link_key,n2) in
    {88}event SendSn(sn,encrypted_sn_p);
    {89}out(att, (encrypted_sn_p,open_ch));
    {90}out(att, (encrypted_sn_p,open_ch));
    {91}in(att, (encrypted_param: bitstring,=open_ch));
    {92}let secure_param_2: bitstring = AES_dec(encrypted_param,link_key,n2) in
    {93}let privacy_key_2: bitstring = kdf2(encryption_key_2,privacy_const) in
    {94}let id_2: bitstring = get_id(privacy_key_2,secure_param_2,secure_param_2,secure_param_2) in
    {95}out(sec_ch_1, (id_2,(sn,id_p)));
    {96}event SteppEnd2
) | (
    {97}in(sec_ch_1, (id_s_1: bitstring,=id_s));
    {98}in(sec_ch_1, (id_p_1: bitstring,(sn_2: bitstring,=id_p)));
    {99}let =id_s_1 = id_p_1 in
    {100}event PairSuccess(sn_2)
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new sec_ch_1: channel;
{2}event SecureChannel(sec_ch_1);
{3}!
(
    {4}in(sec_ch_1, (sn_owner_1: bitstring,=sn_owner));
    {5}event Bounded(sn_owner_1);
    {7}in(att, (hashed_sn_p_1: bitstring,(rand_1: bitstring,=pre_app1)));
    {8}let sn_1: bitstring = hash_table(hashed_sn_p_1) in
    {11}new pri_c_1: bitstring;
    {12}let pub_c_1: bitstring = exp(g,pri_c_1) in
    {15}event SendPubkey(sec_ch_1,pri_c_1,pub_c_1);
    {9}let pri_p_1: bitstring = kdf1(sn_1) in
    {10}let pub_p_1: bitstring = exp(g,pri_p_1) in
    {13}let dhkey_PC_1: bitstring = exp(pub_p_1,pri_c_1) in
    {14}let encryption_key_1: bitstring = derive_encryption_key(dhkey_PC_1,rand_1) in
    {16}out(att, (encryption_key_1,(pub_c_1,pre_app1)));
    {17}in(att, (sn_p1_1: bitstring,=pre_app1));
    {18}event StepsEnd1;
    {19}if (sn_p1_1 = sn_owner_1) then
        {20}out(att, (bound_const,pre_app1))
    else
        {21}out(att, (unbound_const,pre_app1));
        {22}in(att, (sn_p_1: bitstring,(encryption_key_c_1: bitstring,=pre_app1)));
        {23}if (sn_p_1 = sn_owner_1) then
            {24}out(att, (bound_const,pre_app1))
        else
            {25}if ((sn_1 = sn_p_1) && (encryption_key_1 = encryption_key_c_1)) then
            {26}event StepsEnd2;
            {27}new secure_param_1: bitstring;
            {28}event SendSecureParam(secure_param_1);
            {29}out(att, (secure_param_1,pre_app1));
            {30}let privacy_key_1: bitstring = kdf2(encryption_key_1,privacy_const) in
            {31}let id_1: bitstring = get_id(privacy_key_1,secure_param_1,secure_param_1,secure_param_1) in
            {32}out(sec_ch_1, (id_1,id_s))
) | (
    {33}in(att, (hashed_sn_p: bitstring,=open_ch));
    {34}new rand: bitstring;
    {35}out(att, (hashed_sn_p,(rand,pre_app1)));
    {36}in(att, (encryption_key: bitstring,(pub_c: bitstring,=pre_app1)));
    {37}event ReceivePubKey(sec_ch_1,pub_c);
    {38}out(att, (rand,(pub_c,open_ch)));
    {40}new n1_1: bitstring;
    {41}out(att, (n1_1,open_ch));
    {42}in(att, (n2_1: bitstring,=open_ch));
    {39}let auth_key_1: bitstring = kdf2(encryption_key,bleAuthentication_const) in
    {43}let encrypted_nonce1_1: bitstring = AES_enc(smartthings_const,auth_key_1,n2_1) in
    {44}out(att, (encrypted_nonce1_1,open_ch));
    {45}in(att, (encrypted_nonce2_1: bitstring,=open_ch));
    {46}let dec_mes_2_1: bitstring = AES_dec(encrypted_nonce2_1,auth_key_1,n1_1) in
    {47}event StepcEnd1;
    {48}let =smartthings_const = dec_mes_2_1 in
    {50}in(att, (encrypted_sn_p1_1: bitstring,=open_ch));
    {49}let link_key_1: bitstring = kdf2(encryption_key,n2_1) in
    {51}let sn_p1: bitstring = AES_dec(encrypted_sn_p1_1,link_key_1,n2_1) in
    {52}event ReceiveSn(sn_p1);
    {53}out(att, (sn_p1,pre_app1));
    {54}in(att, (encrypted_sn_p_1: bitstring,=open_ch));
    {55}let sn_p: bitstring = AES_dec(encrypted_sn_p_1,link_key_1,n2_1) in
    {56}event ReceiveSn(sn_p);
    {57}out(att, (sn_p,(encryption_key,pre_app1)));
    {58}in(att, (isbound_1: bitstring,=pre_app1));
    {59}if (isbound_1 = unbound_const) then
    {60}in(att, (secure_param: bitstring,=pre_app1));
    {61}event ReceiveSecureParam(secure_param);
    {62}let encrypted_param_1: bitstring = AES_enc(secure_param,link_key_1,n2_1) in
    {63}out(att, (encrypted_param_1,open_ch));
    {66}event StepcEnd2
) | (
    {67}let sn: bitstring = serial_number_const in
    {68}out(sec_ch_1, (sn,sn_owner));
    {69}let hashed_sn_1: bitstring = derive_hashed_sn(sn) in
    {72}out(att, (hashed_sn_1,open_ch));
    {73}in(att, (rand_2: bitstring,(pub_c_2: bitstring,=open_ch)));
    {77}new n2: bitstring;
    {78}out(att, (n2,open_ch));
    {79}in(att, (n1: bitstring,=open_ch));
    {70}let pri_p: bitstring = kdf1(sn) in
    {74}let dhkey_CP_1: bitstring = exp(pub_c_2,pri_p) in
    {75}let encryption_key_2: bitstring = derive_encryption_key(dhkey_CP_1,rand_2) in
    {76}let auth_key: bitstring = kdf2(encryption_key_2,bleAuthentication_const) in
    {80}let encrypted_nonce2: bitstring = AES_enc(smartthings_const,auth_key,n1) in
    {81}out(att, (encrypted_nonce2,open_ch));
    {82}in(att, (encrypted_nonce1: bitstring,=open_ch));
    {83}let dec_mes_1_1: bitstring = AES_dec(encrypted_nonce1,auth_key,n2) in
    {84}event SteppEnd1;
    {85}let =smartthings_const = dec_mes_1_1 in
    {86}let link_key: bitstring = kdf2(encryption_key_2,n2) in
    {87}let encrypted_sn_p: bitstring = AES_enc(sn,link_key,n2) in
    {88}event SendSn(sn,encrypted_sn_p);
    {89}out(att, (encrypted_sn_p,open_ch));
    {90}out(att, (encrypted_sn_p,open_ch));
    {91}in(att, (encrypted_param: bitstring,=open_ch));
    {92}let secure_param_2: bitstring = AES_dec(encrypted_param,link_key,n2) in
    {93}let privacy_key_2: bitstring = kdf2(encryption_key_2,privacy_const) in
    {94}let id_2: bitstring = get_id(privacy_key_2,secure_param_2,secure_param_2,secure_param_2) in
    {95}out(sec_ch_1, (id_2,(sn,id_p)));
    {96}event SteppEnd2
) | (
    {97}in(sec_ch_1, (id_s_1: bitstring,=id_s));
    {98}in(sec_ch_1, (id_p_1: bitstring,(sn_2: bitstring,=id_p)));
    {99}let =id_s_1 = id_p_1 in
    {100}event PairSuccess(sn_2)
)

-- Query not (event(PairSuccess(sn_3)) && event(Bounded(sn_3))) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 136 rules (54 with conclusion selected). Queue: 0 rules.
Starting query not (event(PairSuccess(sn_3)) && event(Bounded(sn_3)))
RESULT not (event(PairSuccess(sn_3)) && event(Bounded(sn_3))) is true.

--------------------------------------------------------------
Verification summary:

Query not (event(PairSuccess(sn_3)) && event(Bounded(sn_3))) is true.

--------------------------------------------------------------

