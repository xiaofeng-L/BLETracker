(* open channel for data communication between central and peripheral *)
free ch: channel.

(* secure channels for user interaction with central and peripheral *)
free central_user_data_out: channel [private].
free central_user_ui: channel [private].
free peripheral_user_data_out: channel [private].
free peripheral_user_ui: channel [private].

(* type defination *)
type random_num.
type public_key.
type private_key.
type dhkey.
type key.
type bt_addr.
type confirmation.
type nonce.

(* BT device bt addresses *)
free addr_A: bt_addr.
free addr_B: bt_addr.

(* yes/no confirmation of 6-digit code comparison *)
free yes_confirm: confirmation.
free no_confirm: confirmation.

event recv_central(bitstring).
event recv_peripheral(bitstring).
event send_central(bitstring).
event send_peripheral(bitstring).

(* Type conversion helper functions *)
fun pubkey2bitstring(public_key): bitstring [typeConverter].

(* Concatenation helper functions *)
fun concat(bitstring, bitstring): bitstring.
fun first_part(bitstring): bitstring.
fun last_part(bitstring): bitstring.
equation forall b1: bitstring, b2: bitstring; first_part(concat(b1, b2)) = b1.
equation forall b1: bitstring, b2: bitstring; last_part(concat(b1, b2)) = b2.

fun SHA256(bitstring): bitstring.

(* Deffie-Hellman key exchange *)
type G.
type exponent.
fun exponent2bitstring(exponent): bitstring [typeConverter].
const gen: G.
fun p224(G, exponent): G.
fun add_exp(exponent, exponent): exponent.
fun add_G(G, G): G.
equation forall x: exponent, y: exponent; p224(p224(gen, x), y) = p224(p224(gen, y), x).

fun exponent2private_key(exponent): private_key [typeConverter].
fun private_key2exponent(private_key): exponent [typeConverter].
fun G2public_key(G): public_key [typeConverter].
fun public_key2G(public_key): G [typeConverter].
fun G2dhkey(G): dhkey [typeConverter].
fun dhkey2bitstring(dhkey): bitstring [typeConverter].

(* private key to public key *)
letfun get_pub_key(pri_k: private_key) = G2public_key(p224(gen, private_key2exponent(pri_k))).

(* dhkey calculation *)
letfun get_dhkey(pub_k: public_key, pri_k: private_key) = G2dhkey(p224(public_key2G(pub_k), private_key2exponent(pri_k))).

fun get_id(G, bitstring): bitstring.

(* BT tables used to pass data between steps *)
(* tables used to pass data between steps *)
table p1c(bt_addr, bitstring).
table p1p(bt_addr, bitstring).
table p2c(bt_addr, bitstring).
table p2p(bt_addr, bitstring).


(* set input/output as precise as described *)
set preciseActions = true.

(* Pairing module *)
(* fixed protocol: perform ECDH to generate rotation parameters *)
let step1c() = (
	in(ch, C1: bitstring);
	new s2: exponent;
	new r2: exponent;
	let S2 = p224(gen, s2) in
	let pri_r2 = exponent2private_key(r2) in
	let pub_r2 = get_pub_key(pri_r2) in
	out(ch, (p224(gen, s2), pub_r2));
	in(ch, (s1: exponent, pub_r1: public_key));
	if C1 = SHA256(concat(exponent2bitstring(s1), pubkey2bitstring(pub_r1))) then (
		let S1 = p224(gen, s1) in
		let P = add_G(S1, S2) in
		let rotation = dhkey2bitstring(get_dhkey(pub_r1, pri_r2)) in
		let id = get_id(P, rotation) in
		insert p1c(addr_B, id)
	)
).

let step1p() = (
	new s1: exponent;
	new r1: exponent;
	let S1 = p224(gen, s1) in
	let pri_r1 = exponent2private_key(r1) in
	let pub_r1 = get_pub_key(pri_r1) in
	let C1 = SHA256(concat(exponent2bitstring(s1), pubkey2bitstring(pub_r1))) in
	out(ch, C1);
	in(ch, (S2: G, pub_r2: public_key));
	out(ch, (s1, pub_r1));
	let P = add_G(S1, S2) in
	let rotation = dhkey2bitstring(get_dhkey(pub_r2, pri_r1)) in
	let id = get_id(P, rotation) in
	insert p1p(addr_A, id)
).


(* User checking module *)
let step2c() = (
	get p1c(=addr_B, id) in
	out(central_user_data_out, id);
	in(central_user_ui, confirm: confirmation);
	if confirm = yes_confirm then
		insert p2c(addr_B, id)
).

let step2p() = (
	get p1p(=addr_A, id) in
	out(peripheral_user_data_out, id);
	in(peripheral_user_ui, confirm: confirmation);
	if confirm = yes_confirm then
		insert p2p(addr_A, id)
).

let user() = (
	in(central_user_data_out, id_c: bitstring);
	in(peripheral_user_data_out, id_p: bitstring);
	if id_c = id_p then (
	  	out(central_user_ui, yes_confirm);
	  	out(peripheral_user_ui, yes_confirm))
	else (
		out(central_user_ui, no_confirm);
  		out(peripheral_user_ui, no_confirm))
).


(* Authenticity verification module *)
let step3c() = (
	get p2c(=addr_B, id) in
	in(ch, salt1: bitstring);
	event send_central(id);
	out(ch, SHA256(concat(id, salt1)));

	new salt2: bitstring;
	out(ch, salt2);
	in(ch, hash_id_p: bitstring);
	if hash_id_p = SHA256(concat(id, salt2)) then
		event recv_central(id)
).

let step3p() = (
	get p2p(=addr_A, id) in
	new salt1: bitstring;
	out(ch, salt1);
	in(ch, hash_id_c: bitstring);
	if hash_id_c = SHA256(concat(id, salt1)) then
		event recv_peripheral(id);

	in(ch, salt2: bitstring);
	event send_peripheral(id);
	out(ch, SHA256(concat(id, salt2)))
).


(* authenticity properties *)
query id: bitstring; event(recv_peripheral(id)) ==> event(send_central(id)).
query id: bitstring; event(recv_central(id)) ==> event(send_peripheral(id)).

process
(step1c()) | (step1p()) | (step2c()) | (step2p()) | (user()) | (step3c()) | (step3p())
