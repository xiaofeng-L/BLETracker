(* open channel for data communication between central and peripheral *)
free ch: channel.

(* secure channels for user interaction with central and peripheral *)
free central_user_data_out: channel [private].
free central_user_ui: channel [private].
free peripheral_user_data_out: channel [private].
free peripheral_user_ui: channel [private].

(* type defination *)
type random_num.
type public_key.
type private_key.
type dhkey.
type key.
type bt_addr.
type iocap.
type confirmation.
type nonce.

(* BT constant value *)
const zero: random_num.
const btlk: bitstring.
const SALT: bitstring.
const brle: bitstring.

(* tables used to pass data between steps *)
table p1c(bt_addr, bitstring).
table p1p(bt_addr, bitstring).
table p2c(bt_addr, bitstring).
table p2p(bt_addr, bitstring).

(* BT device bt addresses *)
free addr_A: bt_addr.
free addr_B: bt_addr.

(* io capabilities *)
free iocap_A: iocap.
free iocap_B: iocap.

(* yes/no confirmation of 6-digit code comparison *)
free yes_confirm: confirmation.
free no_confirm: confirmation.

event recv_central(bitstring).
event recv_peripheral(bitstring).
event send_central(bitstring).
event send_peripheral(bitstring).


(* Type conversion helper functions *)
fun random_num2key(random_num): key [typeConverter].
fun dhkey2key(dhkey): key [typeConverter].
fun bitstring2key(bitstring): key [typeConverter].
fun bitstring2nonce(bitstring): nonce [typeConverter].
fun pubkey2bitstring(public_key): bitstring [typeConverter].
fun random_num2bitstring(random_num): bitstring [typeConverter].
fun bitstring2random_num(bitstring): random_num [typeConverter].
fun btaddr2bitstring(bt_addr): bitstring [typeConverter].
fun iocap2bitstring(iocap): bitstring [typeConverter].

(* Concatenation helper functions *)
fun concat(bitstring, bitstring): bitstring.
fun first_part(bitstring): bitstring.
fun last_part(bitstring): bitstring.
equation forall b1: bitstring, b2: bitstring; first_part(concat(b1, b2)) = b1.
equation forall b1: bitstring, b2: bitstring; last_part(concat(b1, b2)) = b2.

(* Helper functions to get bits from a bitstring *)
fun fist32bit(bitstring): bitstring.
fun next32bit(bitstring): bitstring.
fun last64bit(bitstring): bitstring.

(* BT/BLE defined functions from bluetooth spec *)
fun HMAC_SHA256(key, bitstring): bitstring.
fun SHA256(bitstring): bitstring.

(* cryptographic functions defined in spec *)
letfun f1(pk1: public_key, pk2: public_key, r1: random_num, r2: random_num) =
HMAC_SHA256(random_num2key(r1), concat(concat(pubkey2bitstring(pk1), pubkey2bitstring(pk2)), random_num2bitstring(r2))).

letfun f2(dhk: dhkey, r1: random_num, r2: random_num, b: bitstring, bt1: bt_addr, bt2: bt_addr) =
bitstring2key(HMAC_SHA256(dhkey2key(dhk), concat(concat(concat(concat(random_num2bitstring(r1), random_num2bitstring(r2)), b), btaddr2bitstring(bt1)), btaddr2bitstring(bt2)))).

letfun f3(dhk: dhkey, r1: random_num, r2: random_num, r3: random_num, i: iocap, bt1: bt_addr, bt2: bt_addr) =
HMAC_SHA256(dhkey2key(dhk), concat(concat(concat(concat(concat(random_num2bitstring(r1), random_num2bitstring(r2)), random_num2bitstring(r3)), iocap2bitstring(i)), btaddr2bitstring(bt1)), btaddr2bitstring(bt2))).

fun AES_CMAC(key, bitstring): bitstring.
letfun h6(k: key, b: bitstring) =
bitstring2key(AES_CMAC(k, b)).
letfun h7(b: bitstring, k: key) =
bitstring2key(AES_CMAC(k, b)).

(* symmetric encryption *)
fun AES_CCM(bitstring, key, nonce): bitstring.
reduc forall m: bitstring, k: key, n: nonce; sdec(AES_CCM(m, k, n), k, n) = m.

(* function to derive session key from LTK *)
letfun ltk2sessionk(k: key, b: bitstring) = bitstring2key(AES_CMAC(k, b)).


(* Deffie-Hellman key exchange *)
type G.
type exponent.
const gen: G.
fun p224(G, exponent): G.
fun add_exp(exponent, exponent): exponent.
fun add_G(G, G): G.
equation forall x: exponent, y: exponent; p224(p224(gen, x), y) = p224(p224(gen, y), x).

fun exponent2private_key(exponent): private_key [typeConverter].
fun private_key2exponent(private_key): exponent [typeConverter].
fun G2public_key(G): public_key [typeConverter].
fun public_key2G(public_key): G [typeConverter].
fun G2dhkey(G): dhkey [typeConverter].
fun exponent2bitstring(exponent): bitstring [typeConverter].
fun bitstring2exponent(bitstring): exponent [typeConverter].
fun G2bitstring(G): bitstring [typeConverter].
fun bitstring2G(bitstring): G [typeConverter].

(* private key to public key *)
letfun get_pub_key(pri_k: private_key) = G2public_key(p224(gen, private_key2exponent(pri_k))).

(* dhkey calculation *)
letfun get_dhkey(pub_k: public_key, pri_k: private_key) = G2dhkey(p224(public_key2G(pub_k), private_key2exponent(pri_k))).

fun get_id(G, random_num, random_num): bitstring.


(* set input/output as precise as described *)
set preciseActions = true.

(* Pairing module *)
let step1c() = (
	(* BLE. PK exchange *)
	new pri_C: private_key;
	let pk_A = get_pub_key(pri_C) in
	out(ch, pk_A);
	in(ch, pk_B: public_key);
	let dhkey_AB = get_dhkey(pk_B, pri_C) in
	
	(* BLE. JW auth 1 *)
	new na: random_num;
	let ra = zero in
	let rb = zero in
	in(ch, cb: bitstring);
	out(ch, na);
	in(ch, nb: random_num);

	(* BLE. JW auth 2 *)
	if cb = f1(pk_B, pk_A, nb, zero) then (
		let ea = f3(dhkey_AB, na, nb, rb, iocap_A, addr_A, addr_B) in
		out(ch, ea);
		in(ch, eb: bitstring);
		
		(* BLE. LK and LTK generation *)
		if eb = f3(dhkey_AB, nb, na, ra, iocap_B, addr_B, addr_A) then (
			let lk_key = f2(dhkey_AB, na, nb, btlk, addr_A, addr_B) in
			let le_key = h6(h7(SALT, lk_key), brle) in

			(* Data tran: seesion key generation *)
			new skdm: bitstring;
			new ivm: bitstring;
			out(ch, (skdm, ivm));
			in(ch, (skds: bitstring, ivs: bitstring));
			let session_k: key = ltk2sessionk(le_key, concat(skds, skdm)) in
			let session_n = bitstring2nonce(concat(ivs, ivm)) in
			
			(* Data tran: id sharing *)
			in(ch, C1e: bitstring);
			let C1 = sdec(C1e, session_k, session_n) in
			new s2: exponent;
			new r2: random_num;
			let S2 = p224(gen, s2) in
			out(ch, (AES_CCM(G2bitstring(S2), session_k, session_n), AES_CCM(random_num2bitstring(r2), session_k, session_n)));
			in(ch, (s1e: bitstring, r1e: bitstring));
			let s1 = bitstring2exponent(sdec(s1e, session_k, session_n)) in
			let r1 = bitstring2random_num(sdec(r1e, session_k, session_n)) in
			if C1 = SHA256(concat(exponent2bitstring(s1), random_num2bitstring(r1))) then (
				let S1 = p224(gen, s1) in
				let P = add_G(S1, S2) in
				let d = add_exp(s1, s2) in
				let id = get_id(P, r1, r2) in
				insert p1c(addr_B, id)
				)
			)
		)
).

let step1p() = (
	(* BLE. PK exchange *)
	new pri_P: private_key;
	let pk_B = get_pub_key(pri_P) in
	in(ch, pk_A: public_key);
	out(ch, pk_B);
	let dhkey_BA = get_dhkey(pk_A, pri_P) in
	
	(* BLE. JW auth 1 *)
	new nb: random_num;
	let ra = zero in
	let rb = zero in
	let cb = f1(pk_B, pk_A, nb, zero) in
	out(ch, cb);
	in(ch, na: random_num);
	out(ch, nb);

	(* BLE. JW auth 2 *)
	let eb = f3(dhkey_BA, nb, na, ra, iocap_B, addr_B, addr_A) in
	in(ch, ea: bitstring);
	out(ch, eb);

	(* BLE. LK and LTK generation *)
	if ea = f3(dhkey_BA, na, nb, rb, iocap_A, addr_A, addr_B) then (
		let lk_key = f2(dhkey_BA, na, nb, btlk, addr_A, addr_B) in
		let le_key = h6(h7(SALT, lk_key), brle) in

		(* Data tran: seesion key generation *)
		new skds: bitstring;
		new ivs: bitstring;
		in(ch, (skdm: bitstring, ivm: bitstring));
		out(ch, (skds, ivs));
		let session_k = ltk2sessionk(le_key, concat(skds, skdm)) in  
		let session_n = bitstring2nonce(concat(ivs, ivm)) in
			
		(* Data tran: id sharing *)
		new s1: exponent;
		new r1: random_num;
		let S1 = p224(gen, s1) in
		let C1 = SHA256(concat(exponent2bitstring(s1), random_num2bitstring(r1))) in
		out(ch, AES_CCM(C1, session_k, session_n));
		in(ch, (S2e: bitstring, r2e: bitstring));
		let S2 = bitstring2G(sdec(S2e, session_k, session_n)) in
		let r2 = bitstring2random_num(sdec(r2e, session_k, session_n)) in
		let P = add_G(S1, S2) in
		out(ch, (AES_CCM(exponent2bitstring(s1), session_k, session_n), AES_CCM(random_num2bitstring(r1), session_k, session_n)));
		let id = get_id(P, r1, r2) in
		insert p1p(addr_A, id)
		)
).


(* User checking module *)
let step2c() = (
	get p1c(=addr_B, id) in
	out(central_user_data_out, id);
	in(central_user_ui, confirm: confirmation);
	if confirm = yes_confirm then
		insert p2c(addr_B, id)
).

let step2p() = (
	get p1p(=addr_A, id) in
	out(peripheral_user_data_out, id);
	in(peripheral_user_ui, confirm: confirmation);
	if confirm = yes_confirm then
		insert p2p(addr_A, id)
).

let user() = (
	in(central_user_data_out, id_c: bitstring);
	in(peripheral_user_data_out, id_p: bitstring);
	if id_c = id_p then (
	  	out(central_user_ui, yes_confirm);
	  	out(peripheral_user_ui, yes_confirm))
	else (
		out(central_user_ui, no_confirm);
  		out(peripheral_user_ui, no_confirm))
).


(* Authenticity verification module *)
let step3c() = (
	get p2c(=addr_B, id) in
	in(ch, salt1: bitstring);
	event send_central(id);
	out(ch, SHA256(concat(id, salt1)));

	new salt2: bitstring;
	out(ch, salt2);
	in(ch, hash_id_p: bitstring);
	if hash_id_p = SHA256(concat(id, salt2)) then
		event recv_central(id)
).

let step3p() = (
	get p2p(=addr_A, id) in
	new salt1: bitstring;
	out(ch, salt1);
	in(ch, hash_id_c: bitstring);
	if hash_id_c = SHA256(concat(id, salt1)) then
		event recv_peripheral(id);

	in(ch, salt2: bitstring);
	event send_peripheral(id);
	out(ch, SHA256(concat(id, salt2)))
).


(* authenticity properties *)
query id: bitstring; event(recv_peripheral(id)) ==> event(send_central(id)).
query id: bitstring; event(recv_central(id)) ==> event(send_peripheral(id)).

process
(step1c()) | (step1p()) | (step2c()) | (step2p()) | (user()) | (step3c()) | (step3p())
