free ch: channel.

(* type defination *)
type key.
type iv.


(* Concatenation helper functions *)
fun concat(bitstring, bitstring): bitstring.
fun first_part(bitstring): bitstring.
fun last_part(bitstring): bitstring.
equation forall b1: bitstring, b2: bitstring; first_part(concat(b1, b2)) = b1.
equation forall b1: bitstring, b2: bitstring; last_part(concat(b1, b2)) = b2.
fun first8bytes(bitstring): bitstring.
fun first4bytes(bitstring): bitstring.

(* AES symmetric encrypt *)
fun AES_enc(bitstring, key, iv): bitstring.
fun AES_dec(bitstring, key, iv): bitstring.
equation forall k: key, v: iv, mes: bitstring; AES_dec(AES_enc(mes, k, v), k, v) = mes.

fun derive_key(bitstring, bitstring): key.

const privacy: bitstring.
const signing: bitstring.
free status: bitstring.
free aging: bitstring.
free state: bitstring.
const zero: bitstring.


let signature_rotation(encryption_key: bitstring, seed: bitstring, privacyIV: iv) = (
  new r2: bitstring;
  let privacyKey = derive_key(encryption_key, privacy) in
  let seedi = concat(concat(r2, seed), r2) in
  let IDi = first8bytes(AES_enc(seedi, privacyKey, privacyIV)) in
  let content = concat(status, concat(aging, concat(IDi, concat(state, zero)))) in
  let signingKey = derive_key(encryption_key, signing) in
  let signaturei = first4bytes(AES_enc(content, signingKey, privacyIV)) in
  (* Observational equivalence: real-or-random secrecy *)
  new random: bitstring;
  out(ch, choice[signaturei, random])
).

process
new encryption_key: bitstring;
new seed: bitstring;
new privacyIV: iv;
!signature_rotation(encryption_key, seed, privacyIV)