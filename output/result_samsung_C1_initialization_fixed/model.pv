(* open channel for data communication between central device and peripheral device *)
free open_ch: channel.

(* secure channel for data communication between cloud and pre-installed app in phone *)
free pre_app1: channel [private].

(* secure channel for data communication while producing peripheral device *)
free secure_ch: channel [private].

(* secure channels for user interaction with central and peripheral *)
free central_user_data_out: channel [private].
free central_user_ui: channel [private].
free peripheral_user_data_out: channel [private].
free peripheral_user_ui: channel [private].

(* type defination *)
type random_num.
type public_key.
type private_key.
type dhkey.
type key.
type iv.
type bt_addr.
type confirmation.
type nonce.

free s: bitstring [private].

free yes_confirm: confirmation.
free no_confirm: confirmation.
free serial_number: bitstring.

(* constant value *)
const smartthings: bitstring.
const bleAuthentication: bitstring.
const privacy: bitstring.
const poolsize: bitstring.

(* tables used to pass data between steps *)
table p0s(bitstring, bitstring, public_key).
table p0p(bitstring, bitstring, private_key, public_key).
table p1c(bt_addr, bitstring).
table p1p(bt_addr, bitstring).

(* device bt addresses *)
free addrA: bt_addr.
free addrB: bt_addr.

(* Type conversion helper functions *)
fun bitstring2iv(bitstring): iv [typeConverter].
fun nonce2bitstring(nonce): bitstring [typeConverter].
fun btaddr2bitstring(bt_addr): bitstring [typeConverter].
fun bitstring2key(bitstring): key [typeConverter].


(* Concatenation helper functions *)
fun concat(bitstring, bitstring): bitstring.
fun first_part(bitstring): bitstring.
fun last_part(bitstring): bitstring.
equation forall b1: bitstring, b2: bitstring; first_part(concat(b1, b2)) = b1.
equation forall b1: bitstring, b2: bitstring; last_part(concat(b1, b2)) = b2.

fun SHA256(bitstring): bitstring.
fun AES_enc(bitstring, key, iv): bitstring.
reduc forall k: key, v: iv, mes: bitstring; AES_dec(AES_enc(mes, k, v), k, v) = mes.

(* ECDH key exchange *)
type G.
type exponent.
const gen: G.
fun Curve25519(G, exponent): G.
equation forall x: exponent, y: exponent; Curve25519(Curve25519(gen, x), y) = Curve25519(Curve25519(gen, y), x).

fun exponent2private_key(exponent): private_key [typeConverter].
fun private_key2exponent(private_key): exponent [typeConverter].
fun G2public_key(G): public_key [typeConverter].
fun public_key2G(public_key): G [typeConverter].
fun G2dhkey(G): dhkey [typeConverter].

(* private key to public key *)
letfun get_pub_key(pri_k: private_key) = G2public_key(Curve25519(gen, private_key2exponent(pri_k))).

(* dhkey calculation *)
letfun get_dhkey(pub_k: public_key, pri_k: private_key) = G2dhkey(Curve25519(public_key2G(pub_k), private_key2exponent(pri_k))).

(* Samsung SmartTag key calculation *)
fun derive_encryption_key(dhkey, random_num): bitstring.
fun derive_key(bitstring, bitstring): key.

(* modify and derive private key from bt_addr *)
fun derive_prikey_from_sn(bitstring): private_key.

(* hash table *)
fun derive_hashed_sn(bitstring): bitstring.

(* Calculate all id *)
(* privId = AES(key: privacyKey, iv: iv, mes: seed) *)
fun get_id(key, bitstring, bitstring, bitstring): bitstring.

(* set input/output as precise as described *)
set preciseActions = true.


(* 0. initial setting module *)
let step0s() = (
	in(secure_ch, (sn: bitstring, hashed_sn: bitstring, pub_p: public_key));
	insert p0s(sn, hashed_sn, pub_p)
).

let step0p() = (
	let sn = serial_number in
	let hashed_sn = derive_hashed_sn(sn) in
	new exp_p: exponent;
	let pri_p = exponent2private_key(exp_p) in
	let pub_p = get_pub_key(pri_p) in
	out(secure_ch, (sn, hashed_sn, pub_p));
	insert p0p(sn, hashed_sn, pri_p, pub_p)
).


(* 1. pairing module *)
let step1s() = (
	(* PK exchange *)
	get p0s(sn, hashed_sn, pub_p) in
	in(pre_app1, (hashed_sn_p: bitstring, rand: random_num));
	if hashed_sn = hashed_sn_p then (
			new pri_c: private_key;
			let pub_c = get_pub_key(pri_c) in
			let dhkey_PC = get_dhkey(pub_p, pri_c) in
			let encryption_key = derive_encryption_key(dhkey_PC, rand) in
			out(pre_app1, (encryption_key, pub_c));

			(* id sharing *)
			in(pre_app1, (sn_p: bitstring, encryption_key_c: bitstring));
			if (sn = sn_p) && (encryption_key = encryption_key_c) then (
				new privacy_iv: bitstring;
				new privacy_seed: bitstring;
				let privacy_poolsize = poolsize in
				new time_sync: bitstring;
				out(pre_app1, (privacy_iv, privacy_seed, privacy_poolsize, time_sync));
				let privacy_key = derive_key(encryption_key, privacy) in
				let id = get_id(privacy_key, privacy_iv, privacy_seed, privacy_poolsize) in
				0)
		)
).

let step1c() = (
	(* PK exchange *)
	in(open_ch, hashed_sn_p: bitstring);
	new rand: random_num;
	out(pre_app1, (hashed_sn_p, rand));
	in(pre_app1, (encryption_key: bitstring, pub_c: public_key));
	out(open_ch, (rand, pub_c));

	(* authentication *)
	let auth_key = derive_key(encryption_key, bleAuthentication) in
	new n1: nonce;
	out(open_ch, n1);
	in(open_ch, n2: nonce);
	let encrypted_nonce1 = AES_enc(smartthings, auth_key, bitstring2iv(nonce2bitstring(n2))) in
	out(open_ch, encrypted_nonce1);
	in(open_ch, encrypted_nonce2: bitstring);
	let dec_mes_2 = AES_dec(encrypted_nonce2, auth_key, bitstring2iv(nonce2bitstring(n1))) in
	if smartthings = dec_mes_2 then (
		let link_key = derive_key(encryption_key, nonce2bitstring(n2)) in

		(* id sharing *)
		in(open_ch, encrypted_sn_p: bitstring);
		let sn_p = AES_dec(encrypted_sn_p, link_key, bitstring2iv(nonce2bitstring(n2))) in
		out(pre_app1, (sn_p, encryption_key));
		in(pre_app1, (privacy_iv: bitstring, privacy_seed: bitstring, privacy_poolsize: bitstring, time_sync: bitstring));

		let encrypted_iv = AES_enc(privacy_iv, link_key, bitstring2iv(nonce2bitstring(n2))) in
		let encrypted_seed = AES_enc(privacy_seed, link_key, bitstring2iv(nonce2bitstring(n2))) in
		let encrypted_poolsize = AES_enc(privacy_poolsize, link_key, bitstring2iv(nonce2bitstring(n2))) in
		let encrypted_time = AES_enc(time_sync, link_key, bitstring2iv(nonce2bitstring(n2))) in
		out(open_ch, (encrypted_iv, encrypted_seed, encrypted_poolsize, encrypted_time));
		let privacy_key = derive_key(encryption_key, privacy) in
		let id = get_id(privacy_key, privacy_iv, privacy_seed, privacy_poolsize) in
		insert p1c(addrB, id)
		)
).

let step1p() = (
	get p0p(sn, hashed_sn, pri_p, pub_p) in
	out(open_ch, hashed_sn);
	in(open_ch, (rand: random_num, pub_c: public_key));
	let dhkey_CP = get_dhkey(pub_c, pri_p) in
	let encryption_key = derive_encryption_key(dhkey_CP, rand) in
	
	(* authentication stage 1 *)
	let auth_key = derive_key(encryption_key, bleAuthentication) in
	new n2: nonce;
	in(open_ch, n1: nonce);
	out(open_ch, n2);
	let encrypted_nonce2 = AES_enc(smartthings, auth_key, bitstring2iv(nonce2bitstring(n1))) in
	in(open_ch, encrypted_nonce1: bitstring);
	out(open_ch, encrypted_nonce2);
	let dec_mes_1 = AES_dec(encrypted_nonce1, auth_key, bitstring2iv(nonce2bitstring(n2))) in
	if smartthings = dec_mes_1 then (
		let link_key = derive_key(encryption_key, nonce2bitstring(n2)) in
	
		(* id sharing *)
		out(open_ch, AES_enc(sn, link_key, bitstring2iv(nonce2bitstring(n2))));
		in(open_ch, (encrypted_iv: bitstring, encrypted_seed: bitstring, encrypted_poolsize: bitstring, encrypted_time: bitstring));
		let privacy_iv = AES_dec(encrypted_iv, link_key, bitstring2iv(nonce2bitstring(n2))) in
		let privacy_seed = AES_dec(encrypted_seed, link_key, bitstring2iv(nonce2bitstring(n2))) in
		let privacy_poolsize = AES_dec(encrypted_poolsize, link_key, bitstring2iv(nonce2bitstring(n2))) in
		let time_sync = AES_dec(encrypted_time, link_key, bitstring2iv(nonce2bitstring(n2))) in
		let privacy_key = derive_key(encryption_key, privacy) in
		let id = get_id(privacy_key, privacy_iv, privacy_seed, privacy_poolsize) in
		insert p1p(addrA, id)
	)
).


(* 2. user checking module *)
let step2c() = (
	get p1c(=addrB, id) in
	out(central_user_data_out, id);
	in(central_user_ui, confirm: confirmation);
	new tmp: iv;
	if confirm = yes_confirm then
		out(open_ch, (tmp, AES_enc(s, bitstring2key(id), tmp)))
).

let step2p() = (
	get p1p(=addrA, id) in
	out(peripheral_user_data_out, id);
	in(peripheral_user_ui, confirm: confirmation);
	if confirm = yes_confirm then
		in(open_ch, (tmp: iv, enc_s: bitstring))
).

let user() = (
	in(central_user_data_out, id_c: bitstring);
	in(peripheral_user_data_out, id_p: bitstring);
	if id_c = id_p then (
	  	out(central_user_ui, yes_confirm);
	  	out(peripheral_user_ui, yes_confirm))
	else (
		out(central_user_ui, no_confirm);
  		out(peripheral_user_ui, no_confirm))
).


(* confidentiality properties *)
query attacker(s).

process
(step0s()) | (step0p()) | (step1s()) |(step1c()) | (step1p()) | (step2c()) | (step2p()) | (user())